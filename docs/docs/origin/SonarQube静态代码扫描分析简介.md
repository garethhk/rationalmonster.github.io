# 一、静态代码分析

**Why**：在软件开发过程中，开发团队往往要花费大量的时间和精力发现并修改代码缺陷。而

- 发现BUG越晚，修复的成本越大
- 缺陷引入的大部分是在编码阶段，但发现更多的是在单元测试、集成测试、功能测试阶段
- 30% 至 70% 的代码逻辑设计和编码缺陷是可以通过静态代码分析来发现和修复的

**How**：在编码阶段，可以通过以下手段发现源代码问题，从源头及时规避，保证代码质量

- 静态代码扫描工具
- Code Review

**What**：`Code Review`往往要求大量的时间消耗和相关知识的积累，因此对于软件开发团队来说，使用静态代码分析工具自动化执行代码检查和分析，能够极大地提高软件可靠性并节省软件开发和测试成本。

- 帮助程序开发人员自动执行静态代码分析，快速定位代码隐藏错误和缺陷
- 助代码设计人员更专注于分析和解决代码设计缺陷
- 显著减少在代码逐行检查上花费的时间，提高软件可靠性并节省软件开发和测试成本

常见的一些静态分析工具

- **Checkstyle**：SourceForge 的开源项目，通过检查对代码编码格式，命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，从而有效约束开发人员更好地遵循代码编写规范
- **FindBugs**：由马里兰大学提供的一款开源 Java 静态代码分析工具。FindBugs 通过检查类文件或 JAR 文件，将字节码与一组缺陷模式进行对比从而发现代码缺陷，完成静态代码分析
- **PMD**：由 DARPA 在 SourceForge 上发布的开源 Java 代码静态分析工具。PMD 通过其内置的编码规则对 Java 代码进行静态检查，主要包括对潜在的 bug，未使用的代码，重复的代码，循环体创建新对象等问题的检验



# 二、Sonar简介

- Sonar是一个用于代码质量管理的开源平台，可以从 [七个维度](#1、Sonar检查代码质量的七个维度)检测代码质量

- Sonar可以通过PMD、CheckStyle、Findbugs等代码规则检测工具来检测你的代码，帮助你发现代码的漏洞，Bug，异味等信息。

- Sonar最大的特点就是插件化，可以根据不同的场景需求进行插件化安装，可以同时可以检测Python、C++等多种语言。

- Sonar客户端可以采用`IDE插件`、`Sonar-Scanner插件`、`Ant插件`和`Maven插件`等多种方式，并通过各种不同的分析机制对项目源代码进行分析和扫描，并把分析扫描后的结果上传到sonar的数据库，通过sonar web界面对分析结果进行管理

**Sonar的架构体系**

![](../assets/SonarQube静态代码扫描分析简介-体系架构.png)

- `Project`：是需要被分析的源码
- `SonarQube Scanner`：用于执行代码分析的工具，在Project的根目录下执行，我们还需要在Project下进行SonarQube配置，其中指定了工程的相关信息，还指定了SonarQube Server的地址，SonarQube Scanner分析完毕之后，会将结果上报到该Server。

- `SonarQube Server`：显示分析结果的Web Server，在SonarQube Scanner第一次将一个工程的分析结果上报给SonarQube Server后，Server上会自动创建一个工程显示分析的结果，可以在Server上设置代码质量管理相关的各种配置，如设置代码检查规则（Rule）和质量门限（Quality Gate）等。包含三个子进程（web服务（界面管理）、搜索服务、计算引擎服务（写入数据库））





# 三、自动化扫描分析源代码的流程

## 官方推荐的自动化扫描流程

![](../assets/SonarQube静态代码扫描分析简介-官方推荐自动化扫描流程.png)

## 自动化静态代码扫描流程

![](../assets/SonarQube静态代码扫描分析简介-自动化扫描流程.png)

**本地开发**：JetBrains Intellij IDEA 、Eclipse安装阿里巴巴的代码检查规范插件，可在编写代码时提示规范信息；安装使用sonarlint插件在本地运行代码扫描

**Gitlab**：Gitlab代码仓库可设置事件监听器，例如PUSH事件、Merge Request事件等。发送Web-hook到外部系统

**Jenkins**：Jenkins中可安装Gitlab插件，用于设置特定的Web-hook后端监听器来触发当前任务。

**Jenkins Pipeline**：在Jenkins Pipeline中获取Web-hook信息来拉取代码，然后编译、执行Sonar Scanner扫描源代码文件或二进制文件，最后将扫描的结果发送SnarQube进行存储、展示、管理等操作

**SonarQube**：

# 四、在SonarQube上分析管理代码扫描的结果

## 1、配置代码规则插件

## 2、管理扫描结果

## 3、质量门禁





# 附录

## 1、Sonar检查代码质量的七个维度

- 复杂度分布（complexity）：代码复杂度过高将难以理解、难以维护
- 重复代码（duplications）：程序中包含大量复制粘度的代码是质量低下的表现
- 单元测试（unit tests）：统计并展示单元测试覆盖率
- 编码规范（coding rules）：通过Findbugs、PMD、CheckStyle等规范代码编写
- 注释（commments）：少了可读性差，多了看起来费劲
- 潜在的Bug（potential bugs）：通过Findbugs、PMD、CheckStyle等检测潜在bug
- 结构与设计（architecture & design）：依赖i、耦合等
  

## 2、常见检查分析工具的内置规范

**Checkstyle**：分析源代码文件

- Javadoc 注释：检查类及方法的 Javadoc 注释
- 命名约定：检查命名是否符合命名规范
- 标题：检查文件是否以某些行开头
- Import 语句：检查 Import 语句是否符合定义规范
- 代码块大小，即检查类、方法等代码块的行数
- 空白：检查空白符，如 tab，回车符等
- 修饰符：修饰符号的检查，如修饰符的定义顺序
- 块：检查是否有空块或无效块
- 代码问题：检查重复代码，条件判断，魔数等问题
- 类设计：检查类的定义是否符合规范，如构造函数的定义等问题

**FindBugs**：分析字节码文件

- Bad practice 坏的实践：常见代码错误，用于静态代码检查时进行缺陷模式匹配
- Correctness 可能导致错误的代码，如空指针引用等
- 国际化相关问题：如错误的字符串转换
- 可能受到的恶意攻击，如访问权限修饰符的定义等
- 多线程的正确性：如多线程编程时常见的同步，线程调度问题。
- 运行时性能问题：如由变量定义，方法调用导致的代码低效问题。

**PMD**：：分析源代码文件

- 可能的 Bugs：检查潜在代码错误，如空 try/catch/finally/switch 语句
- 未使用代码（Dead code）：检查未使用的变量，参数，方法
- 复杂的表达式：检查不必要的 if 语句，可被 while 替代的 for 循环
- 重复的代码：检查重复的代码
- 循环体创建新对象：检查在循环体内实例化新对象
- 资源关闭：检查 Connect，Result，Statement 等资源使用之后是否被关闭掉

**Jtest**

- 可能的错误：如内存破坏、内存泄露、指针错误、库错误、逻辑错误和算法错误等
- 未使用代码：检查未使用的变量，参数，方法
- 初始化错误：内存分配错误、变量初始化错误、变量定义冲突
- 命名约定：检查命名是否符合命名规范
- Javadoc 注释：检查类及方法的 Javadoc 注释
- 线程和同步：检验多线程编程时常见的同步，线程调度问题
- 国际化问题：
- 垃圾回收：检查变量及 JDBC 资源是否存在内存泄露隐患
